import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import { config } from "dotenv";
import path from "path";
import { readFileSync } from "fs";
import { rm } from "fs/promises";
import { isValidPath, copyFilesToTargetDir } from "./utils.ts";

// Determine the plugin directory (where the script is called from)
const pluginDir = process.cwd();
const manifestPath = path.join(pluginDir, "manifest.json");
const manifest = JSON.parse(readFileSync(manifestPath, "utf-8"));

config();

const EXTERNAL_DEPS = [
  "obsidian",
  "electron",
  "@codemirror/autocomplete",
  "@codemirror/collab",
  "@codemirror/commands",
  "@codemirror/language",
  "@codemirror/lint",
  "@codemirror/search",
  "@codemirror/state",
  "@codemirror/view",
  "@lezer/common",
  "@lezer/highlight",
  "@lezer/lr",
  ...builtins
];

const BANNER = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/`;

async function validateEnvironment(): Promise<void> {
  const srcMainPath = path.join(pluginDir, "src/main.ts");
  if (!await isValidPath(srcMainPath)) {
    throw new Error("Invalid path for src/main.ts. main.ts must be in the src directory");
  }
  if (!await isValidPath(manifestPath)) {
    throw new Error("Invalid path for manifest.json");
  }
}

function getBuildPath(isProd: boolean): string {
  // If production build without redirection, return plugin directory
  if (isProd && !process.argv.includes("-r")) {
    return pluginDir;
  }

  // Determine which path to use
  const envKey = process.argv.includes("-r") ? "REAL_VAULT" : "TEST_VAULT";
  const vaultPath = process.env[envKey]?.trim();

  // If empty or undefined, we're already in the plugin folder
  if (!vaultPath) {
    return pluginDir;
  }

  // Check if the path already contains the plugins directory path
  const pluginsPath = path.join(".obsidian", "plugins");
  if (vaultPath.includes(pluginsPath)) {
    // Just add the manifest id to complete the path
    return path.join(vaultPath, manifest.id);
  }

  // Otherwise, complete the full path
  return path.join(vaultPath, ".obsidian", "plugins", manifest.id);
}

async function createBuildContext(buildPath: string, isProd: boolean, entryPoints: string[]): Promise<esbuild.BuildContext> {
  return await esbuild.context({
    banner: { js: BANNER },
    minify: isProd,
    entryPoints,
    bundle: true,
    external: EXTERNAL_DEPS,
    format: "cjs",
    target: "esNext",
    platform: "node",
    logLevel: "info",
    sourcemap: isProd ? false : "inline",
    treeShaking: true,
    outdir: buildPath,
    outbase: path.join(pluginDir, "src"),
    plugins: [
      // Plugin pour gÃ©rer les alias de chemin
      {
        name: "path-alias",
        setup: (build): void => {
          build.onResolve({ filter: /^@config\// }, (args) => {
            const relativePath = args.path.replace(/^@config\//, "");
            return {
              path: path.resolve("../obsidian-plugin-config/src", relativePath)
            };
          });

          build.onResolve({ filter: /^@config-scripts\// }, (args) => {
            const relativePath = args.path.replace(/^@config-scripts\//, "");
            return {
              path: path.resolve("../obsidian-plugin-config/scripts", relativePath)
            };
          });
        }
      },
      {
        name: "copy-to-plugins-folder",
        setup: (build): void => {
          build.onEnd(async () => {
            // if real or build
            if (isProd) {
              if (process.argv.includes("-r")) {
                await copyFilesToTargetDir(buildPath);
                console.log(`Successfully installed in ${buildPath}`);
              } else {
                const folderToRemove = path.join(buildPath, "_.._");
                if (await isValidPath(folderToRemove)) {
                  await rm(folderToRemove, { recursive: true });
                }
                console.log("Built done in initial folder");
              }
            }
            // if watch (dev)
            else {
              await copyFilesToTargetDir(buildPath);
            }
          });
        }
      }
    ]
  });
}

async function main(): Promise<void> {
  try {
    await validateEnvironment();
    const isProd = process.argv[2] === "production";
    const buildPath = getBuildPath(isProd);
    console.log(buildPath === pluginDir
      ? "Building in initial folder"
      : `Building in ${buildPath}`);
    const srcStylesPath = path.join(pluginDir, "src/styles.css");
    const rootStylesPath = path.join(pluginDir, "styles.css");
    const stylePath = await isValidPath(srcStylesPath) ? srcStylesPath : await isValidPath(rootStylesPath) ? rootStylesPath : "";
    const mainTsPath = path.join(pluginDir, "src/main.ts");
    const entryPoints = stylePath ? [mainTsPath, stylePath] : [mainTsPath];
    const context = await createBuildContext(buildPath, isProd, entryPoints);

    if (isProd) {
      await context.rebuild();
      process.exit(0);
    } else {
      await context.watch();
    }
  } catch (error) {
    console.error("Build failed:", error);
    process.exit(1);
  }
}

main().catch(console.error);
